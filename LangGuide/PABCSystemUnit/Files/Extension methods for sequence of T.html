<HTML><HEAD><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
<param name="Keyword" value="AdjacentGroup">
<param name="Keyword" value="Batch">
<param name="Keyword" value="Cartesian">
<param name="Keyword" value="ForEach">
<param name="Keyword" value="Incremental">
<param name="Keyword" value="Interleave">
<param name="Keyword" value="JoinIntoString">
<param name="Keyword" value="LastMaxBy">
<param name="Keyword" value="LastMinBy">
<param name="Keyword" value="MaxBy">
<param name="Keyword" value="MinBy">
<param name="Keyword" value="Numerate">
<param name="Keyword" value="Pairwise">
<param name="Keyword" value="Partition">
<param name="Keyword" value="Print">
<param name="Keyword" value="Println">
<param name="Keyword" value="SkipLast">
<param name="Keyword" value="Slice">
<param name="Keyword" value="Sorted">
<param name="Keyword" value="SortedDescending">
<param name="Keyword" value="SplitAt">
<param name="Keyword" value="Tabulate">
<param name="Keyword" value="TakeLast">
<param name="Keyword" value="ToHashSet">
<param name="Keyword" value="ToLinkedList">
<param name="Keyword" value="ToSortedSet">
<param name="Keyword" value="UnZipTuple">
<param name="Keyword" value="WriteLines">
<param name="Keyword" value="ZipTuple"></object>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><link rel="StyleSheet" href="../../../default.css">
</HEAD><body><H1>Extension methods for sequence of T</H1>
<table cellpadding=3><tr><td><code><b>function</b> AdjacentGroup&lt;T&gt;(Self: <b>sequence <b>of</b></b> T): <b>sequence <b>of</b></b> <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Groups consecutive equal elements into sequences and returns a sequence of those sequences</td></tr>
<tr><td><code><b>function</b> Batch&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; size: integer): <b>sequence <b>of</b></b> <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Splits the sequence into sequences with the specified number of elements</td></tr>
<tr><td><code><b>function</b> Batch&lt;T,Res&gt;(Self: <b>sequence <b>of</b></b> T; size: integer; proj: Func&lt;IEnumerable&lt;T&gt;,Res&gt;): <b>sequence <b>of</b></b> Res; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Splits the sequence into sequences with the specified number of elements and applies the provided projection to each sequence</td></tr>
<tr><td><code><b>function</b> Cartesian&lt;T,T1&gt;(Self: <b>sequence <b>of</b></b> T; b: <b>sequence <b>of</b></b> T1): <b>sequence <b>of</b></b> (T,T1); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the Cartesian product of the sequences</td></tr>
<tr><td><code><b>function</b> Cartesian&lt;T,T1,T2&gt;(Self: <b>sequence <b>of</b></b> T; b: <b>sequence <b>of</b></b> T1; func: (T,T1)-&gt;T2): <b>sequence <b>of</b></b> T2; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the Cartesian product of the sequences</td></tr>
<tr><td><code><b>procedure</b> ForEach&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; action: T -&gt; ()); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs the action on each element of the sequence</td></tr>
<tr><td><code><b>procedure</b> ForEach&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; action: (T,integer) -&gt; ()); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs the index-dependent action on each element of the sequence</td></tr>
<tr><td><code><b>function</b> Incremental(Self: <b>sequence <b>of</b></b> integer): <b>sequence <b>of</b></b> integer; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a sequence of differences between adjacent elements of the sequence</td></tr>
<tr><td><code><b>function</b> Incremental(Self: <b><b>array</b> <b>of</b></b> integer): <b>sequence <b>of</b></b> integer; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a sequence of differences between adjacent elements of the sequence</td></tr>
<tr><td><code><b>function</b> Incremental(Self: List&lt;integer&gt;): <b>sequence <b>of</b></b> integer; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a sequence of differences between adjacent elements of the sequence</td></tr>
<tr><td><code><b>function</b> Incremental(Self: LinkedList&lt;integer&gt;): <b>sequence <b>of</b></b> integer; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a sequence of differences between adjacent elements of the sequence</td></tr>
<tr><td><code><b>function</b> Incremental(Self: <b>sequence <b>of</b></b> real): <b>sequence <b>of</b></b> real; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a sequence of differences between adjacent elements of the sequence</td></tr>
<tr><td><code><b>function</b> Incremental(Self: <b><b>array</b> <b>of</b></b> real): <b>sequence <b>of</b></b> real; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a sequence of differences between adjacent elements of the sequence</td></tr>
<tr><td><code><b>function</b> Incremental(Self: List&lt;real&gt;): <b>sequence <b>of</b></b> real; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a sequence of differences between adjacent elements of the sequence</td></tr>
<tr><td><code><b>function</b> Incremental(Self: LinkedList&lt;real&gt;): <b>sequence <b>of</b></b> real; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a sequence of differences between adjacent elements of the sequence</td></tr>
<tr><td><code><b>function</b> Incremental&lt;T,T1&gt;(Self: <b>sequence <b>of</b></b> T; func: (T,T)-&gt;T1): <b>sequence <b>of</b></b> T1; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a sequence of differences between adjacent elements of the sequence. Function <b>func</b> is used for subtraction</td></tr>
<tr><td><code><b>function</b> Incremental&lt;T,T1&gt;(Self: <b>sequence <b>of</b></b> T; func: (T,T,integer)-&gt;T1): <b>sequence <b>of</b></b> T1; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a sequence of differences between adjacent elements of the sequence. Function <b>func</b> is used for subtraction</td></tr>
<tr><td><code><b>function</b> Interleave&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; a: <b>sequence <b>of</b></b> T): <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interleaves the elements of two sequences</td></tr>
<tr><td><code><b>function</b> Interleave&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; a,b: <b>sequence <b>of</b></b> T): <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interleaves the elements of three sequences</td></tr>
<tr><td><code><b>function</b> Interleave&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; a,b,c: <b>sequence <b>of</b></b> T): <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interleaves the elements of four sequences</td></tr>
<tr><td><code><b>function</b> JoinIntoString&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; delim: string): string; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts the elements of the sequence to strings then concatenates them using <b>delim</b> as a delimiter</td></tr>
<tr><td><code><b>function</b> JoinIntoString&lt;T&gt;(Self: <b>sequence <b>of</b></b> T): string; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts the elements of the sequence to strings then concatenates them using space as a delimiter</td></tr>
<tr><td><code><b>function</b> LastMaxBy&lt;T, TKey&gt;(Self: <b>sequence <b>of</b></b> T; selector: T -&gt; TKey): T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the last element of the sequence with the maximum value of the key</td></tr>
<tr><td><code><b>function</b> LastMinBy&lt;T, TKey&gt;(Self: <b>sequence <b>of</b></b> T; selector: T -&gt; TKey): T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the last element of the sequence with the minimum value of the key</td></tr>
<tr><td><code><b>function</b> MaxBy&lt;T, TKey&gt;(Self: <b>sequence <b>of</b></b> T; selector: T -&gt; TKey): T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the first element of the sequence with the maximum value of the key</td></tr>
<tr><td><code><b>function</b> MinBy&lt;T, TKey&gt;(Self: <b>sequence <b>of</b></b> T; selector: T -&gt; TKey): T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the first element of the sequence with the minimum value of the key</td></tr>
<tr><td><code><b>function</b> Numerate&lt;T&gt;(Self: <b>sequence <b>of</b></b> T): <b>sequence <b>of</b></b> (integer,T); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numbers the elements of the sequence starting with 1</td></tr>
<tr><td><code><b>function</b> Numerate&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; from: integer): <b>sequence <b>of</b></b> (integer,T); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numbers the elements of the sequence starting with the spicified number <b>from</b></td></tr>
<tr><td><code><b>function</b> Pairwise&lt;T&gt;(Self: <b>sequence <b>of</b></b> T): <b>sequence <b>of</b></b> (T,T); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transforms the sequence into a sequence of pairs of neighboring elements</td></tr>
<tr><td><code><b>function</b> Pairwise&lt;T,Res&gt;(Self: <b>sequence <b>of</b></b> T; func:(T,T)-&gt;Res): <b>sequence <b>of</b></b> Res; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transforms the sequence into a sequence of pairs of neighboring elements then applies function <b>func</b> to each pair to form the result</td></tr>
<tr><td><code><b>function</b> Partition&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; cond: T-&gt;boolean): (<b>sequence <b>of</b></b> T,<b>sequence <b>of</b></b> T); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Splits the sequence into two sequences based on the condition <b>cond</b></td></tr>
<tr><td><code><b>function</b> Partition&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; cond: (T,integer)-&gt;boolean): (<b>sequence <b>of</b></b> T,<b>sequence <b>of</b></b> T); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Splits the sequence into two sequences based on the condition <b>cond</b>, which is index dependant</td></tr>
<tr><td><code><b>function</b> Print&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; delim: string): <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Displays the sequence on the screen using <b>delim</b> as a delimiter</td></tr>
<tr><td><code><b>function</b> Print&lt;T&gt;(Self: <b>sequence <b>of</b></b> T): <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Displays the sequence on the screen using space as a delimiter</td></tr>
<tr><td><code><b>function</b> Println&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; delim: string): <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Displays the sequence on the screen using <b>delim</b> as a delimiter and starts a new line</td></tr>
<tr><td><code><b>function</b> Println&lt;T&gt;(Self: <b>sequence <b>of</b></b> T): <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Displays the sequence on the screen using space as a delimiter and starts a new line</td></tr>
<tr><td><code><b>function</b> SkipLast&lt;T&gt;(self: <b>sequence <b>of</b></b> T; count: integer := 1): <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Skips the last <b>count</b> elements of the sequence</td></tr>
<tr><td><code><b>function</b> Slice&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; from,step: integer): <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a slice with the specified beginning and step &gt; 0</td></tr>
<tr><td><code><b>function</b> Slice&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; from,step,count: integer): <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a slice with the specified beginning, step &gt; 0, and lenght limitation (not more than <b>count</b> elements)</td></tr>
<tr><td><code><b>function</b> Sorted&lt;T&gt;(Self: <b>sequence <b>of</b></b> T): <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a sequence sorted in ascending order</td></tr>
<tr><td><code><b>function</b> SortedDescending&lt;T&gt;(Self: <b>sequence <b>of</b></b> T): <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a sequence sorted in descending order</td></tr>
<tr><td><code><b>function</b> SplitAt&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; ind: integer): (<b>sequence <b>of</b></b> T,<b>sequence <b>of</b></b> T); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Splits the sequence into two at the specified index</td></tr>
<tr><td><code><b>function</b> Tabulate&lt;T,T1&gt;(Self: <b>sequence <b>of</b></b> T; F: T-&gt;T1): <b>sequence <b>of</b></b> (T,T1); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a sequence that represents a tabulation of the function F</td></tr>
<tr><td><code><b>function</b> TakeLast&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; count: integer): <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the last <b>count</b> elements of the sequence</td></tr>
<tr><td><code><b>function</b> ToHashSet&lt;T&gt;(Self: <b>sequence <b>of</b></b> T): HashSet&lt;T&gt;; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <b>HashSet</b> built upon the sequence</td></tr>
<tr><td><code><b>function</b> ToLinkedList&lt;T&gt;(Self: <b>sequence <b>of</b></b> T): LinkedList&lt;T&gt;; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <b>LinkedList</b> built upon the sequence</td></tr>
<tr><td><code><b>function</b> ToSortedSet&lt;T&gt;(Self: <b>sequence <b>of</b></b> T): SortedSet&lt;T&gt;; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <b>SortedSet</b> built upon the sequence</td></tr>
<tr><td><code><b>function</b> UnZipTuple&lt;T,T1&gt;(Self: <b>sequence <b>of</b></b> (T,T1)): (<b>sequence <b>of</b></b> T,<b>sequence <b>of</b></b> T1); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns two sequences built upon a sequence of two-element tuples by splitting the tuples</td></tr>
<tr><td><code><b>function</b> UnZipTuple&lt;T,T1,T2&gt;(Self: <b>sequence <b>of</b></b> (T,T1,T2)): (<b>sequence <b>of</b></b> T,<b>sequence <b>of</b></b> T1,<b>sequence <b>of</b></b> T2); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns three sequences built upon a sequence of three-element tuples by splitting the tuples</td></tr>
<tr><td><code><b>function</b> UnZipTuple&lt;T,T1,T2,T3&gt;(Self: <b>sequence <b>of</b></b> (T,T1,T2,T3)): (<b>sequence <b>of</b></b> T,<b>sequence <b>of</b></b> T1,<b>sequence <b>of</b></b> T2,<b>sequence <b>of</b></b> T3); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns four sequences built upon a sequence of four-element tuples by splitting the tuples</td></tr>
<tr><td><code><b>function</b> WriteLines(Self: <b>sequence <b>of</b></b> string; fname: string): <b>sequence <b>of</b></b> string; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints the sequence of strings to a file</td></tr>
<tr><td><code><b>function</b> ZipTuple&lt;T,T1&gt;(Self: <b>sequence <b>of</b></b> T; a: <b>sequence <b>of</b></b> T1): <b>sequence <b>of</b></b> (T,T1); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Combines two sequences into a sequence of two-element tuples</td></tr>
<tr><td><code><b>function</b> ZipTuple&lt;T,T1,T2&gt;(Self: <b>sequence <b>of</b></b> T; a: <b>sequence <b>of</b></b> T1; b: <b>sequence <b>of</b></b> T2): <b>sequence <b>of</b></b> (T,T1,T2); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Combines three sequences into a sequence of three-element tuples</td></tr>
<tr><td><code><b>function</b> ZipTuple&lt;T,T1,T2,T3&gt;(Self: <b>sequence <b>of</b></b> T; a: <b>sequence <b>of</b></b> T1; b: <b>sequence <b>of</b></b> T2; c: <b>sequence <b>of</b></b> T3): <b>sequence <b>of</b></b> (T,T1,T2,T3); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Combines four sequences into a sequence of four-element tuples</td></tr>
</table></body></HTML>
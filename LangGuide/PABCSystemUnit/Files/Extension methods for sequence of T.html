<HTML><HEAD><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
<param name="Keyword" value="AdjacentGroup">
<param name="Keyword" value="Batch">
<param name="Keyword" value="Cartesian">
<param name="Keyword" value="ForEach">
<param name="Keyword" value="Incremental">
<param name="Keyword" value="Interleave">
<param name="Keyword" value="JoinIntoString">
<param name="Keyword" value="LastMaxBy">
<param name="Keyword" value="LastMinBy">
<param name="Keyword" value="MaxBy">
<param name="Keyword" value="MinBy">
<param name="Keyword" value="Numerate">
<param name="Keyword" value="Pairwise">
<param name="Keyword" value="Partition">
<param name="Keyword" value="Print">
<param name="Keyword" value="Println">
<param name="Keyword" value="SkipLast">
<param name="Keyword" value="Slice">
<param name="Keyword" value="Sorted">
<param name="Keyword" value="SortedDescending">
<param name="Keyword" value="SplitAt">
<param name="Keyword" value="Tabulate">
<param name="Keyword" value="TakeLast">
<param name="Keyword" value="ToHashSet">
<param name="Keyword" value="ToLinkedList">
<param name="Keyword" value="ToSortedSet">
<param name="Keyword" value="UnZipTuple">
<param name="Keyword" value="WriteLines">
<param name="Keyword" value="ZipTuple"></object>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><link rel="StyleSheet" href="../../../default.css">
</HEAD><body><H1>Методы расширения для sequence of T</H1>
<table cellpadding=3><tr><td><code><b>function</b> AdjacentGroup&lt;T&gt;(Self: <b>sequence <b>of</b></b> T): <b>sequence <b>of</b></b> <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Группирует одинаковые подряд идущие элементы, получая последовательность последовательностей</td></tr>
<tr><td><code><b>function</b> Batch&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; size: integer): <b>sequence <b>of</b></b> <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Разбивает последовательность на серии длины size</td></tr>
<tr><td><code><b>function</b> Batch&lt;T,Res&gt;(Self: <b>sequence <b>of</b></b> T; size: integer; proj: Func&lt;IEnumerable&lt;T&gt;,Res&gt;): <b>sequence <b>of</b></b> Res; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Разбивает последовательность на серии длины size и применяет проекцию к каждой серии</td></tr>
<tr><td><code><b>function</b> Cartesian&lt;T,T1&gt;(Self: <b>sequence <b>of</b></b> T; b: <b>sequence <b>of</b></b> T1): <b>sequence <b>of</b></b> (T,T1); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Декартово произведение последовательностей</td></tr>
<tr><td><code><b>function</b> Cartesian&lt;T,T1,T2&gt;(Self: <b>sequence <b>of</b></b> T; b: <b>sequence <b>of</b></b> T1; func: (T,T1)-&gt;T2): <b>sequence <b>of</b></b> T2; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Декартово произведение последовательностей</td></tr>
<tr><td><code><b>procedure</b> ForEach&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; action: T -&gt; ()); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Применяет действие к каждому элементу последовательности</td></tr>
<tr><td><code><b>procedure</b> ForEach&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; action: (T,integer) -&gt; ()); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Применяет действие к каждому элементу последовательности, зависящее от номера элемента</td></tr>
<tr><td><code><b>function</b> Incremental(Self: <b>sequence <b>of</b></b> integer): <b>sequence <b>of</b></b> integer; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает последовательность разностей соседних элементов исходной последовательности</td></tr>
<tr><td><code><b>function</b> Incremental(Self: <b><b>array</b> <b>of</b></b> integer): <b>sequence <b>of</b></b> integer; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает последовательность разностей соседних элементов исходной последовательности</td></tr>
<tr><td><code><b>function</b> Incremental(Self: List&lt;integer&gt;): <b>sequence <b>of</b></b> integer; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает последовательность разностей соседних элементов исходной последовательности</td></tr>
<tr><td><code><b>function</b> Incremental(Self: LinkedList&lt;integer&gt;): <b>sequence <b>of</b></b> integer; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает последовательность разностей соседних элементов исходной последовательности</td></tr>
<tr><td><code><b>function</b> Incremental(Self: <b>sequence <b>of</b></b> real): <b>sequence <b>of</b></b> real; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает последовательность разностей соседних элементов исходной последовательности</td></tr>
<tr><td><code><b>function</b> Incremental(Self: <b><b>array</b> <b>of</b></b> real): <b>sequence <b>of</b></b> real; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает последовательность разностей соседних элементов исходной последовательности</td></tr>
<tr><td><code><b>function</b> Incremental(Self: List&lt;real&gt;): <b>sequence <b>of</b></b> real; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает последовательность разностей соседних элементов исходной последовательности</td></tr>
<tr><td><code><b>function</b> Incremental(Self: LinkedList&lt;real&gt;): <b>sequence <b>of</b></b> real; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает последовательность разностей соседних элементов исходной последовательности</td></tr>
<tr><td><code><b>function</b> Incremental&lt;T,T1&gt;(Self: <b>sequence <b>of</b></b> T; func: (T,T)-&gt;T1): <b>sequence <b>of</b></b> T1; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает последовательность разностей соседних элементов исходной последовательности. В качестве функции разности используется func</td></tr>
<tr><td><code><b>function</b> Incremental&lt;T,T1&gt;(Self: <b>sequence <b>of</b></b> T; func: (T,T,integer)-&gt;T1): <b>sequence <b>of</b></b> T1; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает последовательность разностей соседних элементов исходной последовательности. В качестве функции разности используется func</td></tr>
<tr><td><code><b>function</b> Interleave&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; a: <b>sequence <b>of</b></b> T): <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Чередует элементы двух последовательностей</td></tr>
<tr><td><code><b>function</b> Interleave&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; a,b: <b>sequence <b>of</b></b> T): <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Чередует элементы трех последовательностей</td></tr>
<tr><td><code><b>function</b> Interleave&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; a,b,c: <b>sequence <b>of</b></b> T): <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Чередует элементы четырех последовательностей</td></tr>
<tr><td><code><b>function</b> JoinIntoString&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; delim: string): string; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Преобразует элементы последовательности в строковое представление, после чего объединяет их в строку, используя delim в качестве разделителя</td></tr>
<tr><td><code><b>function</b> JoinIntoString&lt;T&gt;(Self: <b>sequence <b>of</b></b> T): string; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Преобразует элементы последовательности в строковое представление, после чего объединяет их в строку, используя пробел в качестве разделителя</td></tr>
<tr><td><code><b>function</b> LastMaxBy&lt;T, TKey&gt;(Self: <b>sequence <b>of</b></b> T; selector: T -&gt; TKey): T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает последний элемент последовательности с максимальным значением ключа</td></tr>
<tr><td><code><b>function</b> LastMinBy&lt;T, TKey&gt;(Self: <b>sequence <b>of</b></b> T; selector: T -&gt; TKey): T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает последний элемент последовательности с минимальным значением ключа</td></tr>
<tr><td><code><b>function</b> MaxBy&lt;T, TKey&gt;(Self: <b>sequence <b>of</b></b> T; selector: T -&gt; TKey): T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает первый элемент последовательности с максимальным значением ключа</td></tr>
<tr><td><code><b>function</b> MinBy&lt;T, TKey&gt;(Self: <b>sequence <b>of</b></b> T; selector: T -&gt; TKey): T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает первый элемент последовательности с минимальным значением ключа</td></tr>
<tr><td><code><b>function</b> Numerate&lt;T&gt;(Self: <b>sequence <b>of</b></b> T): <b>sequence <b>of</b></b> (integer,T); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Нумерует последовательность с единицы</td></tr>
<tr><td><code><b>function</b> Numerate&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; from: integer): <b>sequence <b>of</b></b> (integer,T); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Нумерует последовательность с номера from</td></tr>
<tr><td><code><b>function</b> Pairwise&lt;T&gt;(Self: <b>sequence <b>of</b></b> T): <b>sequence <b>of</b></b> (T,T); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Превращает последовательность в последовательность пар соседних элементов</td></tr>
<tr><td><code><b>function</b> Pairwise&lt;T,Res&gt;(Self: <b>sequence <b>of</b></b> T; func:(T,T)-&gt;Res): <b>sequence <b>of</b></b> Res; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Превращает последовательность в последовательность пар соседних элементов, применяет func к каждой паре полученных элементов и получает новую последовательность</td></tr>
<tr><td><code><b>function</b> Partition&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; cond: T-&gt;boolean): (<b>sequence <b>of</b></b> T,<b>sequence <b>of</b></b> T); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Разделяет последовательности на две по заданному условию</td></tr>
<tr><td><code><b>function</b> Partition&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; cond: (T,integer)-&gt;boolean): (<b>sequence <b>of</b></b> T,<b>sequence <b>of</b></b> T); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Разделяет последовательности на две по заданному условию, в котором участвует индекс</td></tr>
<tr><td><code><b>function</b> Print&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; delim: string): <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Выводит последовательность на экран, используя delim в качестве разделителя</td></tr>
<tr><td><code><b>function</b> Print&lt;T&gt;(Self: <b>sequence <b>of</b></b> T): <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Выводит последовательность на экран, используя пробел в качестве разделителя</td></tr>
<tr><td><code><b>function</b> Println&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; delim: string): <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Выводит последовательность на экран, используя delim в качестве разделителя, и переходит на новую строку</td></tr>
<tr><td><code><b>function</b> Println&lt;T&gt;(Self: <b>sequence <b>of</b></b> T): <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Выводит последовательность на экран, используя пробел качестве разделителя, и переходит на новую строку</td></tr>
<tr><td><code><b>function</b> SkipLast&lt;T&gt;(self: <b>sequence <b>of</b></b> T; count: integer := 1): <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает последовательность без последних count элементов</td></tr>
<tr><td><code><b>function</b> Slice&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; from,step: integer): <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает срез последовательности от номера from с шагом step &gt; 0</td></tr>
<tr><td><code><b>function</b> Slice&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; from,step,count: integer): <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает срез последовательности от номера from с шагом step &gt; 0 длины не более count</td></tr>
<tr><td><code><b>function</b> Sorted&lt;T&gt;(Self: <b>sequence <b>of</b></b> T): <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает отсортированную по возрастанию последовательность</td></tr>
<tr><td><code><b>function</b> SortedDescending&lt;T&gt;(Self: <b>sequence <b>of</b></b> T): <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает отсортированную по убыванию последовательность</td></tr>
<tr><td><code><b>function</b> SplitAt&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; ind: integer): (<b>sequence <b>of</b></b> T,<b>sequence <b>of</b></b> T); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Разбивает последовательности на две в позиции ind</td></tr>
<tr><td><code><b>function</b> Tabulate&lt;T,T1&gt;(Self: <b>sequence <b>of</b></b> T; F: T-&gt;T1): <b>sequence <b>of</b></b> (T,T1); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Табулирует функцию последовательностью</td></tr>
<tr><td><code><b>function</b> TakeLast&lt;T&gt;(Self: <b>sequence <b>of</b></b> T; count: integer): <b>sequence <b>of</b></b> T; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает последние count элементов последовательности</td></tr>
<tr><td><code><b>function</b> ToHashSet&lt;T&gt;(Self: <b>sequence <b>of</b></b> T): HashSet&lt;T&gt;; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает множество HashSet по данной последовательности</td></tr>
<tr><td><code><b>function</b> ToLinkedList&lt;T&gt;(Self: <b>sequence <b>of</b></b> T): LinkedList&lt;T&gt;; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает LinkedList по данной последовательности</td></tr>
<tr><td><code><b>function</b> ToSortedSet&lt;T&gt;(Self: <b>sequence <b>of</b></b> T): SortedSet&lt;T&gt;; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возвращает множество SortedSet по данной последовательности</td></tr>
<tr><td><code><b>function</b> UnZipTuple&lt;T,T1&gt;(Self: <b>sequence <b>of</b></b> (T,T1)): (<b>sequence <b>of</b></b> T,<b>sequence <b>of</b></b> T1); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Разъединяет последовательность двухэлементных кортежей на две последовательности</td></tr>
<tr><td><code><b>function</b> UnZipTuple&lt;T,T1,T2&gt;(Self: <b>sequence <b>of</b></b> (T,T1,T2)): (<b>sequence <b>of</b></b> T,<b>sequence <b>of</b></b> T1,<b>sequence <b>of</b></b> T2); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Разъединяет последовательность трехэлементных кортежей на три последовательности</td></tr>
<tr><td><code><b>function</b> UnZipTuple&lt;T,T1,T2,T3&gt;(Self: <b>sequence <b>of</b></b> (T,T1,T2,T3)): (<b>sequence <b>of</b></b> T,<b>sequence <b>of</b></b> T1,<b>sequence <b>of</b></b> T2,<b>sequence <b>of</b></b> T3); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Разъединяет последовательность четырехэлементных кортежей на четыре последовательности</td></tr>
<tr><td><code><b>function</b> WriteLines(Self: <b>sequence <b>of</b></b> string; fname: string): <b>sequence <b>of</b></b> string; <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Выводит последовательность строк в файл</td></tr>
<tr><td><code><b>function</b> ZipTuple&lt;T,T1&gt;(Self: <b>sequence <b>of</b></b> T; a: <b>sequence <b>of</b></b> T1): <b>sequence <b>of</b></b> (T,T1); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Объединяет две последовательности в последовательность двухэлементных кортежей</td></tr>
<tr><td><code><b>function</b> ZipTuple&lt;T,T1,T2&gt;(Self: <b>sequence <b>of</b></b> T; a: <b>sequence <b>of</b></b> T1; b: <b>sequence <b>of</b></b> T2): <b>sequence <b>of</b></b> (T,T1,T2); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Объединяет три последовательности в последовательность трехэлементных кортежей</td></tr>
<tr><td><code><b>function</b> ZipTuple&lt;T,T1,T2,T3&gt;(Self: <b>sequence <b>of</b></b> T; a: <b>sequence <b>of</b></b> T1; b: <b>sequence <b>of</b></b> T2; c: <b>sequence <b>of</b></b> T3): <b>sequence <b>of</b></b> (T,T1,T2,T3); <b>extensionmethod</b>;</code>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Объединяет четыре последовательности в последовательность четырехэлементных кортежей</td></tr>
</table></body></HTML>